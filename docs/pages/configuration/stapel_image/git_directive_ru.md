---
title: Добавление исходного кода из git-репозиториев
sidebar: documentation
permalink: ru/documentation/configuration/stapel_image/git_directive.html
ref: documentation_configuration_stapel_image_git_directive
lang: ru
summary: |
  <a class="google-drawings" href="https://docs.google.com/drawings/d/e/2PACX-1vRUYmRNmeuP14OcChoeGzX_4soCdXx7ZPgNqm5ePcz9L_ItMUqyolRoJyPL7baMNoY7P6M0B08eMtsb/pub?w=2031&amp;h=144" data-featherlight="image">
      <img src="https://docs.google.com/drawings/d/e/2PACX-1vRUYmRNmeuP14OcChoeGzX_4soCdXx7ZPgNqm5ePcz9L_ItMUqyolRoJyPL7baMNoY7P6M0B08eMtsb/pub?w=1016&amp;h=72">
  </a>

  <div class="tabs">
    <a href="javascript:void(0)" class="tabs__btn active" onclick="openTab(event, 'tabs__btn', 'tabs__content', 'local')">Local</a>
    <a href="javascript:void(0)" class="tabs__btn" onclick="openTab(event, 'tabs__btn', 'tabs__content', 'remote')">Remote</a>
  </div>

  <div id="local" class="tabs__content active">
  <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">git</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">add</span><span class="pi">:</span> <span class="s">&lt;absolute path in git repository&gt;</span>
    <span class="na">to</span><span class="pi">:</span> <span class="s">&lt;absolute path inside image&gt;</span>
    <span class="na">owner</span><span class="pi">:</span> <span class="s">&lt;owner&gt;</span>
    <span class="na">group</span><span class="pi">:</span> <span class="s">&lt;group&gt;</span>
    <span class="na">includePaths</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">&lt;path or glob relative to path in add&gt;</span>
    <span class="na">excludePaths</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">&lt;path or glob relative to path in add&gt;</span>
    <span class="na">stageDependencies</span><span class="pi">:</span>
      <span class="na">install</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">&lt;path or glob relative to path in add&gt;</span>
      <span class="na">beforeSetup</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">&lt;path or glob relative to path in add&gt;</span>
      <span class="na">setup</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">&lt;path or glob relative to path in add&gt;</span></code></pre>
  </div></div>     
  </div>

  <div id="remote" class="tabs__content">
  <div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">git</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">url</span><span class="pi">:</span> <span class="s">&lt;git repo url&gt;</span>
    <span class="na">branch</span><span class="pi">:</span> <span class="s">&lt;branch name&gt;</span>
    <span class="na">commit</span><span class="pi">:</span> <span class="s">&lt;commit&gt;</span>
    <span class="na">tag</span><span class="pi">:</span> <span class="s">&lt;tag&gt;</span>
    <span class="na">add</span><span class="pi">:</span> <span class="s">&lt;absolute path in git repository&gt;</span>
    <span class="na">to</span><span class="pi">:</span> <span class="s">&lt;absolute path inside image&gt;</span>
    <span class="na">owner</span><span class="pi">:</span> <span class="s">&lt;owner&gt;</span>
    <span class="na">group</span><span class="pi">:</span> <span class="s">&lt;group&gt;</span>
    <span class="na">includePaths</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">&lt;path or glob relative to path in add&gt;</span>
    <span class="na">excludePaths</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="s">&lt;path or glob relative to path in add&gt;</span>
    <span class="na">stageDependencies</span><span class="pi">:</span>
      <span class="na">install</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">&lt;path or glob relative to path in add&gt;</span>
      <span class="na">beforeSetup</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">&lt;path or glob relative to path in add&gt;</span>
      <span class="na">setup</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">&lt;path or glob relative to path in add&gt;</span>
  </code></pre>
  </div></div>
  </div>
---

## Что такое git-маппинг?

***Git-маппинг*** определяет, какой файл или папка из git-репозитория должны быть добавлены в конкретное место образа. Git-репозиторий может быть как локальным репозиторием, в котором находится файл конфигурации сборки (`werf.yaml`), так и удаленным (внешним) репозиторием (в этом случае указывается адрес репозитория и версия кода — ветка, тэг или конкретный коммит).

Werf добавляет файлы из git-репозитория в образ копируя их с помощью [git archive](https://git-scm.com/docs/git-archive) (при первоначальном добавлении файлов) либо накладывая git patch. При повторных сборках и появлении изменений в git-репозитории, Werf добавляет patch к собранному ранее образу — чтобы в конечном образе отразить необходимые изменения файлов и папок. Более подробно, механизм переноса файлов в образ и накладывания патчей рассматривается в соответствующей секции [далее...](#подробнее-про-gitarchive-gitcache-gitlatestpatch)

Конфигурация _git-маппинга_ поддерживает фильтры, что позволяет используя необходимое количество _git_маппингов_ сформировать практически любую файловую структуру в образе. Также, вы можете указать группу и владельца конечных файлов в образе, что освобождает от необходимости делать это (`chown`) отдельной командой.

В Werf реализована поддержка сабмодулей git (git submodules), и если Werf определяет, что какая-то часть git-маппинга является сабмодулем, то принимаются соответствующие меры, чтобы обрабатывать изменения в сабмодулях корректно.

> Все git-сабмодули проекта связаны с конкретным коммитом, поэтому все разработчики работающие с репозиторием использующим сабмодуль, получают одинаковое содержимое. Werf не инициализирует, не обновляет сабмодули, а использует соответствующие связанные коммиты.

Пример добавления файлов из папки `/src` локального git-репозитория в папку `/app` собираемого образа, и добавления кода PhantomJS из удаленного репозитория в папку `/src/phantomjs` собираемого образа:

```yaml
git:
- add: /src
  to: /app
- url: https://github.com/ariya/phantomjs
  add: /
  to: /src/phantomjs
```

## Зачем использовать git-маппинг?

Основная идея использования git-маппинга — добавление истории к сборочному процессу.

### Наложение патчей вместо копирования

Большинство коммитов в репозитории реального приложения относятся к обновлению кода самого приложения. В этом случае, если компиляция приложения не требуется, то для получения нового образа достаточно применить исправления к файлам в предыдущем образе.

### Удаленные репозитории

Сборка конечного образа может зависеть от файлов в других репозитория. Werf позволяет добавлять файлы из удаленных репозиториев, а также отслеживать их изменение.

## Синтаксис

Для добавления кода из локального git-репозитория используется следующий синтаксис:

- `add` — (не обязательный параметр) путь к директории или файлу, содержимое которого (которой) нужно добавить в образ. Указывается абсолютный путь *относительно корня* репозитория, — т.е. он должен начинаться с `/`. По умолчанию копируется все содержимое репозитория, т.е. отсутствие параметра `add` равносильно указанию `add: /`;
- `to` — путь внутри образа, куда будет скопировано соответствующее содержимое;
- `owner` — имя или id пользователя-владельца файлов в образе;
- `group` — имя или id группы-владельца файлов в образе;
- `excludePaths` — список исключений (маска) при рекурсивном копировании файлов и папок. Указывается относительно пути, указанного в `add`;
- `includePaths` — список масок файлов и папок для рекурсивного копирования. Указывается относительно пути, указанного в `add`;
- `stageDependencies` — список масок файлов и папок для указания зависимости пересборки стадии от их изменений. Позволяет указать, при изменении каких файлов и папок необходимо принудительно пересобирать конкретную пользовательскую стадию. Более подробно рассматривается [здесь]({{ site.baseurl }}/ru/documentation/configuration/stapel_image/assembly_instructions.html).

При использовании удаленных репозиториев дополнительно используются следующие параметры:
- `url` — адрес удаленного репозитория;
- `branch`, `tag`, `commit` — имя ветки, тэга или коммита соответственно. По умолчанию — ветка master.

## Использование git-маппинга

### Копирование директорий

Параметр `add` определяет источник, путь в git-репозитории, откуда файлы рекурсивно копируются в образ и помещаются по адресу, указанному в параметре `to`. Если параметр не определен, то по умолчанию используется значение `/`, т.е. копируется весь репозиторий.
Пример простейшей конфигурации, добавляющей содержимое всего локального git-репозитория в образ в папку `/app`.

```yaml
git:
- add: /
  to: /app
```

Если в репозитории была следующая структура файлов и папок:

![git repository files tree]({{ site.baseurl }}/images/build/git_mapping_01.png)

То в образе будет следующая структура файлов и папок:

![image files tree]({{ site.baseurl }}/images/build/git_mapping_02.png)

Вы также можете указывать несколько _git-маппингов_. Пример:

```yaml
git:
- add: /src
  to: /app/src
- add: /assets
  to: /static
```

Если в репозитории была следующая структура файлов и папок:

![git repository files tree]({{ site.baseurl }}/images/build/git_mapping_03.png)

То в образе будет следующая структура файлов и папок:

![image files tree]({{ site.baseurl }}/images/build/git_mapping_04.png)

Следует отметить, что конфигурация git-маппинга не похожа например на копирование типа `cp -r / src / app`. Параметр `add` указывает *содержимое* каталога, которое будет рекурсивно копироваться из репозитория. Поэтому, если папка `/assets` со всем содержимым из репозитория должна быть скопирована в папку `/app/assets` образа, то имя *assets* вы должны указать два раза. Либо, как вариант, вы можете использовать [фильтр](#использование-фильтров), — например параметр `includePaths`.

Примеры обоих вариантов, которые вы можете использовать для достижения одинакового результата:
```yaml
git:
- add: /assets
  to: /app/assets
```

либо

```yaml
git:
- add: /
  to: /app
  includePaths: assets
```

> В Werf нет какого-либо ограничения или соглашения на счет использования `/` в конце, как например в rsync. Т.о. `add: /src` и `add: /src/` — одно и тоже.

### Копирование файла

В случае с копированием файла (когда вы указываете в параметре `add` конкретный файл) действует тот же принцип — вы указываете в параметре `add` содержимое какого файла нужно скопировать, и в параметре `to` — название файла в образе, который будет содержать это содержимое (т.е. также два раза). Это дает вам возможнось изменять имя файла при добавлении его из git-репозитория в образ.

```yaml
git:
- add: /config/prod.yaml
  to: /app/conf/production.yaml
```

### Изменение владельца

При добавлении файла из git-репозитория вы можете указать имя и/или группу владельца файлов в образе. Добавляемым файлам и папкам в образе после копирования будут установлены соответствующие права. Пользователь и группа могут быть указаны как именем так и чиловым id (userid, groupid).

Пример использования:

```yaml
git:
- add: /src/index.php
  to: /app/index.php
  owner: www-data
```

Если указан только параметр `owner`, как в приведенном примере, то группой-владельцем устанавливается основная группа указанного пользователя в системе.

В результате, в папку `/app` образа будет добавлен файл `index.php` и ему будут установлены следующие права:

![index.php owned by www-data user and group]({{ site.baseurl }}/images/build/git_mapping_05.png)

Если значения параметра `owner` или `group` не числовые id, а текстовые (т.е. названия соответствнно пользователя и группы), то соответствующие пользователь и группа должны существовать в системе. Их нужно добавить заранее при необходимости, иначе при сборке возникнет ошибка.

```yaml
git:
- add: /src/index.php
  to: /app/index.php
  owner: wwwdata
```

### Использование фильтров

Парамеры фильтров — `includePaths` и `excludePaths` используются при составлении списка файлов для добавления. Эти параметры содержат набор путей или масок, применяемых соответственно для включения и исключения списка файлов и папок при добавлении в образ.

Фильтр `excludePaths` работает следующим образом: каждая маска списка применяется к каждому файлу, найденному по пути `add`. Если файл удовлетворяет хотябы одной маске, — файл исключается из списка файлов на добавление. Если файл не удовлетворяет ни одной маске — файл добавляется в образ.

Фильтр `includePaths` работает наоборот — если файл удовлетворяет хотябы одной маске, — файл добавляется в образ.

Конфигурация _Git-маппинга_ может содержать оба Фильтра. В этом случае файл добавляется в образ если его путь удовлетворяет хотябы одной маске `includePaths` и не удовлетворяет ни одной маске `excludePaths`.

Пример:

```yaml
git:
- add: /src
  to: /app
  includePaths:
  - '**/*.php'
  - '**/*.js'
  excludePaths:
  - '**/*-dev.*'
  - '**/*-test.*'
```

В приведенном примере добавляются `.php` и `.js` файлы из папки  `/src` исключая файлы с суффиксом `-dev.` или `-test.` в имени файла.

При определении соответствия файла маске, применяется следующий алгоритм:
 - определяется абсолютный путь к очередному файлу в репозитории;
 - путь сравнивается с масками, определенными в `includePaths` и `excludePaths`, либо с конкретным указанным путем:
   - путь в параметре `add` объединяется с маской или указанным путем из параметров `includePaths` и `excludePaths`;
   - оба варианта проверяются с учетом правил применения глобальных шаблонов: если файл удовлетворяет маске — он включается (в случае `includePaths`), либо исключается (в случае `excludePaths`).
 - путь сравнивается с масками, определенными в `includePaths` и `excludePaths`, либо с конкретным указанным путем с учетом дополнительных условий:
   - путь в параметре `add` объединяется с маской или указанным путем из параметров `includePaths` и `excludePaths` и объединяется с суффиксом `**/*` к шаблону;
   - оба варианта проверяются с учетом правил применения глобальных шаблонов: если файл удовлетворяет маске — он включается (в случае `includePaths`), либо исключается (в случае `excludePaths`).

> Последний шаг в алгоритме, с добалвнием  суффикса`**/*` сделан для удобства — вам достаточно указать название папки в параметрах *git-маппинга*, чтобы все ее содержимое удовлетворяло шаблону параметра.

Маска может содержать следующие шаблоны:

- `*` — удовлетворяет любому файлу. Шаблон включает `.` и исключает `/`.
- `**` — удовлетворяет директории со всем ее содержимым, рекурсивно.
- `?` — удовлетворяет любому однму символу в имени файла (аналогично regexp-шаблону `.{1}`)
- `[set]` — удовлетворяет любому символу из указанного набора символов. Аналогично использованию в regexp-шаблонах, включая указание диапазонов типа `[^a-z]`.
- `\` — экранирует следующий символ

Маска, которая начинается с шаблона `*` или `**`, должна быть взята в одинарныеили двойные кавычки в `werf.yaml`:
 - `"*.rb"` — двойные кавычки
- `'**/*'` — одинарные кавычки

Примеры фильтров:

```yaml
add: /src
to: /app
includePaths:
# удовлетворяет всем php файлам, расположенным конкретно в папке /src
- '*.php'

# удовлетворяет всем phph файлам рекурсивно, начиная с папки /src
# (также удовлетворяет файлам *.php, т.к. '.' включается шаблон **)
- '**/*.php'

# удовлетворяет всем файлам в папке /src/module1 рекурсивно
- module1
```

Фильтр `includePaths` может применяться для копирования одного файла без изменения имени. Пример:
```yaml
git:
- add: /src
  to: /app
  includePaths: index.php
```

### Наложение путей копирования

Если вы определяете несколько *git-маппингов*, вы должны учитывать, что при наложении путей в образе в параметре `to` вы можете столкнуться с невозможностью добавления файлов. Пример:

```yaml
git:
- add: /src
  to: /app
- add: /assets
  to: /app/assets
```

Чтобы избежать ошибок сборки, Werf определяет возможные наложения касающиеся фильтров `includePaths` и `excludePaths`, и если такое наложение присутствует, то Werf пытается разрешить самые простые конфликты, неявно добавляя соответствущий параметр `excludePaths` в git-маппинг. Однако, такое поведение может все-таки привести к ножиданным результатам, поэтому лучше всего избегать наложения путей при определении git-маппингов.

В примере выше, Werf в итоге неявно добавит параметр  `excludePaths` и итоговая конфигурация будет равнозначна следующей:

```yaml
git:
- add: /src
  to: /app
  excludePaths:  # Werf добавил этот фильтр, чтобы исключить конфлакт наложения результирующих путей
  - assets       # между /src/assets и /assets
- add: /assets
  to: /app/assets
```

## Работа с удаленными репозиториями

Werf может использовать удаленные (внешние) репозитории в качестве источника файлов. Для указания адреса внешнего репозитория используется параметр `url` *git-маппинга*. Werf поддерживает работу с удаленными репозиториями по протоколам `https` и `git+ssh`.

### https

Синтаксис для работы по протоколу `https`:

{% raw %}
```yaml
git:
- url: https://[USERNAME[:PASSWORD]@]repo_host/repo_path[.git/]
```
{% endraw %}

Указание логина и пароля при доступ по `https` опционально.

Пример доступа к репозиторию из pipeline GitLab CI с использованием переменных окружения:

{% raw %}
```yaml
git:
- url: https://{{ env "CI_REGISTRY_USER" }}:{{ env "CI_JOB_TOKEN" }}@registry.gitlab.company.name/common/helper-utils.git
```
{% endraw %}

В приведенном примере используется метод [env](http://masterminds.github.io/sprig/os.html) библиотеки [Sprig](http://masterminds.github.io/sprig/) для доступа к переменным окружения.

### git, ssh

Доступ к удаленному репозиторию с помощью протокола git защищается с использованием доступа поверх ssh. Это распространенная практика, используемая в частности GitHub, Bitbucket, GitLab, Gogs, Gitolite и т.д. Обычно адрес репозитория выглядит следующим образом:

```yaml
git:
- url: git@gitlab.company.name:project_group/project.git
```

Для работы с удаленными репозиториями по ssh необходимо понимать, как Werf находит ssh-ключи (читай далее подробнее).

#### Работа с ssh-ключами

Ssh-ключи для доступа предоставляются через ssh-agent. Ssh-agent — это демон, который работает через файловый сокет, путь к которому хранится в переменной окружения `SSH_AUTH_SOCK`. Werf монтирует этот файловый сокет во все _сборочные контейнеры_ и устанавливает переменную окружения `SSH_AUTH_SOCK`. Т.о. соединение с удаленным git-репозиторием устанавливается с использованием ключей, зарегистрированных в запущенном ssh-агенте.

Werf использует следующий алгоритм для определения запущенного ssh-агента:

- Werf запущен с ключем `--ssh-key` (одним или несколькими):
  - Запускается временный ssh-агент в который добавляются указанные при запуске Werf ключи. Эти ключи используются при всех операциях с удаленными репозиториями.
  - Уже запущенный ssh-агент игнорируется.
- Werf запущен без указания ключа `--ssh-key` и есть запущенный ssh-агент:
  - Используется переменная окружения `SSH_AUTH_SOCK`, ключи добавляются в соответствующий ssh-агент и используются далее при всех операциях работы с удаленными репозиториями.
- Werf запущен без указания ключа `--ssh-key` и нет запущенного ssh-агента:
  - Если существует файл `~/.ssh/id_rsa`, запускается временный ssh-агент, в который добавляется ключ из файла `~/.ssh/id_rsa`.
- Если ни один из вариантов не применим  — ssh-агент не запускается и при операциях с внешними git-репозиториями не используются никакие ssh-ключи. Сборка образа с объявленными удаленными репозиториями в _git-маппинге_ завершится с ошибкой.

## Подробнее про gitArchive, gitCache, gitLatestPatch

Далее будет более подробно рассмотрен процесс добавления файлов в конечный образ. Как упоминалось ранее, Docker-образ состоит из набора слоёв. Чтобы понимать, какие слои создает Werf, представим что сборка основана на трех коммитах: `1`, `2` и `3`:

- Сборка коммита 1. Исходя из конфигурации _git-маппинга_, все соответствующие файлы добавляются в один слой. Сам процесс добавления выполняется с помощью `git archive`. Получившийся слой соответствует стадии _gitArchive_.
- Сборка коммита 2. Накладывается патч с изменениями файлов, в результате чего получается еще один слой. Получившийся слой соответствует стадии _gitLatestPatch_.
- Сборка коммита 3. Файлы уже добавлены, и Werf накладывает патч, обновляя слой _gitLatestPatch_.

Последовательность сборки для этих коммитов можно представить ​​следующим образом:

| | gitArchive | --- | gitLatestPatch |
|---|:---:|:---:|:---:|
| Сделан коммит 1, сборка в 10:00 | файлы согласно коммита 1 | --- | - |
| Сделан коммит 2, сборка в 10:05 | файлы согласно коммита 1 | --- | файлы согласно коммита 2 |
| Сделан коммит 3, сборка в 10:15 | файлы согласно коммита 1 | --- | файлы согласно коммита 3 |

Пустая колонка между стадиями `gitArchive` и `gitLatestPatch` в приведенной последовательности не случайна. С увеличением числа коммитов, размер патча между первым и текущим коммитом будет также расти и может стать довольно большим, что увеличит размер последнего слоя и общий размер всех стадий. Чтобы избежать роста размера слоя стадии `gitLatestPatch`, Werf может добавить промежуточный слой стадии _gitCache_.

Чтобы проиллюстрировать, как Werf работает с этими тремя стадиями и как изменится алгоритм по сравнению с приведенным ранее, возьмем пример работы с семью коммитами. Алгоритм будет следующий:

- Сборка коммита 1. Файлы также добавляются в единый слой исходя из конфигурации _git-маппинга_. Процесс добавления выполняется с помощью `git archive`. Получившийся слой соответствует стадии _gitArchive_.
- Сборка коммита 2. Размер патча между коммитами `1` и `2` не превышает 1 MiB, поэтому создается один слой стадии _gitLatestPatch_, содержащий изменения между коммитами `1` и `2`.
- Сборка коммита 3. Размер патча между коммитами `1` и `3` не превышает 1 MiB, поэтому слой, соответствующий стадии _gitLatestPatch_ заменяется слоем, содержащим изменения между коммитами `1` и `3`.
- Сборка коммита 4. Размер патча между коммитами `1` и `4` превышает 1 MiB. Добавляется слой стадии _gitCache_, содержащий разность между коммитами `1` и `4`.
- Сборка коммита 5. Размер патча между коммитами `4` и `5` не превышает 1 MiB, поэтому создается один слой _gitLatestPatch_, содержащий разность между коммитами `4` и `5`.

Описанный алгоритм иллюстрирует, что коммиты добавляются начиная с момента сборки, но когда объем патчей становится довольно большим, накопленные изменения сохраняются в отдельном слое — слое стадии _gitCache_. При наличии слоя стадии _gitCache_, наложение патчей при последующих коммитах, для формирования слоя стадии _gitLatestPatch_ будет вестись относительно слоя стадии _gitCache_. Такое поведение позволяет сократить общий объем стадий.

| | gitArchive | gitCache | gitLatestPatch |
|---|:---:|:---:|:---:|
| Сделан коммит 1, сборка в 12:00 |  1 |  - | - |
| Сделан коммит 2, сборка в 12:19 |  1 |  - | 2 |
| Сделан коммит 3, сборка в 12:25 |  1 |  - | 3 |
| Сделан коммит 4, сборка в 12:45 |  1 | *4 | - |
| Сделан коммит 5, сборка в 12:57 |  1 |  4 | 5 |

\* — размер патча для коммита `4` превышает 1 MiB, поэтому на основе патча создается слой для стадии _gitCache_.

### Сброс стадии gitArchive

В некоторых случая вам может потребоваться сбросить стадию _gitArchive_. Например, чтобы уменьшить общий размер стадии и размер конечного образа.

Чтобы показать, когда проблема нежелательного роста образа может стать актуальной, рассмотрим (хоть и довольно редкий) случай добавления файла размером 2GiB в git-репозиторий. При первой сборке произойдет добавление файла в слой стадии _gitArchive_. Допустим, затем, в результате оптимизайций, размер файла уменьшился до 1.6GiB. Новый коммит с такими изменениями создаст слой стадии _gitCache_. Размер образа станет 3.6GiB, 2GiB из которых — старая версия файла в кэше. Принудителная пересборка стадии _gitArchive_ позволит уменьшить размер образа до 1.6GiB. Приведенный пример хоть и редкий, но позволяет наглядно показать зависимость между слоями стадий.

Сбросить стадию _gitArchive_ можно указав в сообщении к коммиту строку **[werf reset]** или **[reset werf]**.

Предположим, что в приведенном выше примере был сделан коммит `6` содержащий в сообщении строку **[werf reset]**. Тогда историю сборки можно представить примерно так:

| | gitArchive | gitCache | gitLatestPatch |
|---|:---:|:---:|:---:|
| Сделан коммит 1, сборка в 12:00 |  1 |  - | - |
| Сделан коммит 2, сборка в 12:19 |  1 |  - | 2 |
| Сделан коммит 3, сборка в 12:25 |  1 |  - | 3 |
| Сделан коммит 4, сборка в 12:45 |  1 | *4 | - |
| Сделан коммит 5, сборка в 12:57 |  1 |  4 | 5 |
| Сделан коммит 6, сборка в 13:22 |  *6 |  - | - |

\* — коммит `6` содержит строку **[werf reset]** в сообщении, что приводит к пересборке стадии _gitArchive_.

### Rebase и _git-стадии_

Каждая стадия хранит специальные метки с данными SHA тех коммитов, из которых стадия было собрана. Эти коммиты используются для создания патчей следующей по алгоритму стадии (по сути это `git diff COMMIT_FROM_PREVIOUS_GIT_STAGE LATEST_COMMIT` для каждого _git- маппинга_).

Таким образом, если какой-либо сохраненный коммит не находится в git-репозитории (например, после выполнения rebase), то Werf пересобирает эту стадию с учетом последнего коммита.
